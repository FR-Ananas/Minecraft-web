<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Minecraft 3D</title>
<style>
  html, body {margin:0;padding:0;overflow:hidden;height:100%;font-family:sans-serif;}
  #joystick, #jump, #break, #place {
    position: absolute; z-index: 10; touch-action: none; font-size: 16px; 
  }
  #joystick {bottom: 20px; left: 20px; width: 100px; height: 100px; background: rgba(0,0,0,0.2); border-radius:50%;}
  button {padding:10px; border:none; border-radius:5px; background:rgba(0,0,0,0.3); color:white;}
  #jump {bottom: 140px; right: 20px;}
  #break {bottom: 80px; right: 20px;}
  #place {bottom: 20px; right: 20px;}
</style>
</head>
<body>
<div id="joystick"></div>
<button id="jump">Jump</button>
<button id="break">Casser</button>
<button id="place">Poser</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.155/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.3/dist/nipplejs.min.js"></script>
<script>

// ==============================
// SCÈNE, CAMERA, RENDERER
// ==============================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ==============================
// PLAYER
// ==============================
const PLAYER_HEIGHT = 1.8;
const player = new THREE.Object3D();
player.position.set(8, PLAYER_HEIGHT+10, 8);
scene.add(player);
player.add(camera);

// ==============================
// LUMIÈRES
// ==============================
scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(10, 20, 10));
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// ==============================
// TEXTURES
// ==============================
const textureLoader = new THREE.TextureLoader();
const textures = {
  0: textureLoader.load('texture_un.png'),
  1: textureLoader.load('texture_deux.png'),
  2: textureLoader.load('texture_trois.png'),
  3: textureLoader.load('texture_quatre.png')
};
for(let key in textures){textures[key].magFilter=THREE.NearestFilter;textures[key].minFilter=THREE.NearestFilter;}
const materials = {
  0: new THREE.MeshStandardMaterial({map:textures[0]}),
  1: new THREE.MeshStandardMaterial({map:textures[1]}),
  2: new THREE.MeshStandardMaterial({map:textures[2]}),
  3: new THREE.MeshStandardMaterial({map:textures[3]})
};

// ==============================
// BLOC
// ==============================
const blockGeometry = new THREE.BoxGeometry(1,1,1);

// ==============================
// MONDE FIXE
// ==============================
const WORLD_WIDTH=16, WORLD_DEPTH=16, WORLD_HEIGHT=26;
const instancedMeshes=[];
for(let i=0;i<4;i++){
  instancedMeshes[i]=new THREE.InstancedMesh(blockGeometry, materials[i], WORLD_WIDTH*WORLD_DEPTH*WORLD_HEIGHT);
  instancedMeshes[i].count=0;
  scene.add(instancedMeshes[i]);
}
const blocks=[];

function generateWorld(){
  let counts=[0,0,0,0];
  for(let y=0;y>-WORLD_HEIGHT;y--){
    for(let x=0;x<WORLD_WIDTH;x++){
      for(let z=0;z<WORLD_DEPTH;z++){
        let matIndex;
        if(y===0) matIndex=0;
        else if(y>=-4) matIndex=1;
        else if(y>=-15) matIndex=2;
        else matIndex=3;

        const dummy=new THREE.Object3D();
        dummy.position.set(x,y,z);
        dummy.updateMatrix();
        const idx=counts[matIndex];
        instancedMeshes[matIndex].setMatrixAt(idx,dummy.matrix);
        counts[matIndex]++;

        blocks.push({position:new THREE.Vector3(x,y,z), matIndex});
      }
    }
  }
  for(let i=0;i<4;i++){
    instancedMeshes[i].count=counts[i];
    instancedMeshes[i].instanceMatrix.needsUpdate=true;
  }
}
generateWorld();

// ==============================
// HIGHLIGHT
// ==============================
const highlightMaterial = new THREE.MeshBasicMaterial({color:0xffff00, wireframe:true});
const highlightMesh = new THREE.Mesh(blockGeometry, highlightMaterial);
highlightMesh.visible=false;
scene.add(highlightMesh);

// ==============================
// POSE / CASSE BLOCS
// ==============================
function modifyBlock(x,y,z,action){
  if(action==='remove'){
    const index=blocks.findIndex(b=>b.position.x===x && b.position.y===y && b.position.z===z);
    if(index!==-1){blocks.splice(index,1);updateInstancedMeshes();}
  } else if(action==='add'){
    const matIndex=y===0?0:y>=-4?1:y>=-15?2:3;
    blocks.push({position:new THREE.Vector3(x,y,z), matIndex});
    updateInstancedMeshes();
  }
}

function updateInstancedMeshes(){
  let counts=[0,0,0,0];
  for(let i=0;i<4;i++) instancedMeshes[i].count=0;
  for(let b of blocks){
    const dummy=new THREE.Object3D();
    dummy.position.copy(b.position);
    dummy.updateMatrix();
    const idx=counts[b.matIndex];
    instancedMeshes[b.matIndex].setMatrixAt(idx,dummy.matrix);
    counts[b.matIndex]++;
  }
  for(let i=0;i<4;i++){
    instancedMeshes[i].count=counts[i];
    instancedMeshes[i].instanceMatrix.needsUpdate=true;
  }
}

// ==============================
// CONTROLES
// ==============================
let isLocked=false, pitch=0, yaw=0;
const direction=new THREE.Vector3();
const move={forward:false,backward:false,left:false,right:false};
const speed=5;

document.body.addEventListener('click',()=>document.body.requestPointerLock());
document.addEventListener('pointerlockchange',()=>isLocked=document.pointerLockElement===document.body);

document.addEventListener('mousemove',e=>{
  if(!isLocked) return;
  const sens=0.002;
  yaw-=e.movementX*sens;
  pitch-=e.movementY*sens;
  pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
  player.rotation.y=yaw;
  camera.rotation.x=pitch;
});

// ==============================
// TOUCH / MOBILE
// ==============================
const joystick = nipplejs.create({zone: document.getElementById('joystick'), mode:'static', position:{left:'50px', bottom:'50px'}});
joystick.on('move', (evt, data)=>{
  if(!data) return;
  move.forward=data.vector.y<-0.3;
  move.backward=data.vector.y>0.3;
  move.left=data.vector.x<-0.3;
  move.right=data.vector.x>0.3;
});
joystick.on('end', ()=>{move.forward=move.backward=move.left=move.right=false;});

document.getElementById('jump').addEventListener('touchstart', ()=>{if(onGround){velocityY=jumpStrength;onGround=false;}});
document.getElementById('break').addEventListener('touchstart', raycastBreak);
document.getElementById('place').addEventListener('touchstart', raycastPlace);

// ==============================
// PHYSIQUE
// ==============================
let velocityY=0, onGround=false;
const gravity=-20, jumpStrength=8;

// ==============================
// BOUCLE
// ==============================
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const delta=clock.getDelta();

  // --- GAMEPAD
  const gamepads = navigator.getGamepads();
  if(gamepads[0]){
    const gp=gamepads[0];
    move.left=gp.axes[0]<-0.2;
    move.right=gp.axes[0]>0.2;
    move.forward=gp.axes[1]<-0.2;
    move.backward=gp.axes[1]>0.2;
    if(gp.buttons[0].pressed && onGround){velocityY=jumpStrength;onGround=false;}
    if(gp.buttons[1].pressed) raycastBreak();
    if(gp.buttons[2].pressed) raycastPlace();
    yaw-=gp.axes[2]*0.05;
    pitch-=gp.axes[3]*0.05;
    pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
    player.rotation.y=yaw;
    camera.rotation.x=pitch;
  }

  // --- DEPLACEMENT
  direction.set(0,0,0);
  if(move.forward) direction.z-=1;
  if(move.backward) direction.z+=1;
  if(move.left) direction.x-=1;
  if(move.right) direction.x+=1;
  direction.normalize();
  if(isLocked){
    let moveX=direction.x*speed*delta, moveZ=direction.z*speed*delta;
    const blocked=checkHorizontalCollisions(moveX, moveZ);
    player.translateX(blocked.deltaX);
    player.translateZ(blocked.deltaZ);
  }

  // --- GRAVITE
  velocityY+=gravity*delta;
  player.position.y+=velocityY*delta;

  onGround=false;
  for(let b of blocks){
    if(player.position.x>b.position.x-0.5 && player.position.x<b.position.x+0.5 &&
       player.position.z>b.position.z-0.5 && player.position.z<b.position.z+0.5){
      const dy=player.position.y-b.position.y;
      if(dy<=PLAYER_HEIGHT && dy>=0){
        player.position.y=b.position.y+PLAYER_HEIGHT;
        velocityY=0;
        onGround=true;
      }
    }
  }

  // --- Highlight
  if(isLocked){
    const raycaster=new THREE.Raycaster();
    const dir=new THREE.Vector3();
    camera.getWorldDirection(dir);
    raycaster.set(camera.getWorldPosition(new THREE.Vector3()), dir);

    let closest=null, minDist=Infinity;
    for(let b of blocks){
      const box = new THREE.Box3().setFromCenterAndSize(b.position.clone(), new THREE.Vector3(1,1,1));
      const intersect = raycaster.ray.intersectBox(box, new THREE.Vector3());
      if(intersect){
        const dist=raycaster.ray.origin.distanceTo(intersect);
        if(dist<minDist){minDist=dist;closest=b;}
      }
    }
    if(closest && minDist<5){highlightMesh.position.copy(closest.position);highlightMesh.visible=true;}
    else highlightMesh.visible=false;
  }

  renderer.render(scene,camera);
}
animate();

// ==============================
// COLLISIONS HORIZONTALES
// ==============================
function checkHorizontalCollisions(dx,dz){
  const newPos = player.position.clone(); newPos.x+=dx; newPos.z+=dz;
  for(let b of blocks){
    if(Math.abs(b.position.x-newPos.x)<0.5 && Math.abs(b.position.z-newPos.z)<0.5 && Math.abs(b.position.y-player.position.y)<PLAYER_HEIGHT) return {deltaX:0,deltaZ:0};
  }
  return {deltaX:dx, deltaZ:dz};
}

// ==============================
// RAYCAST UTIL
// ==============================
function getRaycastBlock(){
  const raycaster=new THREE.Raycaster();
  const dir=new THREE.Vector3();
  camera.getWorldDirection(dir);
  raycaster.set(camera.getWorldPosition(new THREE.Vector3()), dir);
  let closest=null, minDist=Infinity, hitFace=null;
  for(let b of blocks){
    const box = new THREE.Box3().setFromCenterAndSize(b.position.clone(), new THREE.Vector3(1,1,1));
    const intersect = raycaster.ray.intersectBox(box, new THREE.Vector3());
    if(intersect){
      const dist=raycaster.ray.origin.distanceTo(intersect);
      if(dist<minDist){
        minDist=dist; closest=b;
        const localPoint = intersect.clone().sub(b.position);
        if(Math.abs(localPoint.x-0.5)<0.01) hitFace='right';
        else if(Math.abs(localPoint.x+0.5)<0.01) hitFace='left';
        else if(Math.abs(localPoint.y-0.5)<0.01) hitFace='top';
        else if(Math.abs(localPoint.y+0.5)<0.01) hitFace='bottom';
        else if(Math.abs(localPoint.z-0.5)<0.01) hitFace='front';
        else if(Math.abs(localPoint.z+0.5)<0.01) hitFace='back';
      }
    }
  }
  if(!closest) return null;
  return {block:closest, face:hitFace};
}

// ==============================
// ACTIONS
// ==============================
function raycastBreak(){
  const r=getRaycastBlock();
  if(r) modifyBlock(r.block.position.x, r.block.position.y, r.block.position.z, 'remove');
}

function raycastPlace(){
  const r=getRaycastBlock();
  if(!r) return;
  const pos=r.block.position.clone();
  switch(r.face){
    case 'top': pos.y+=1; break;
    case 'bottom': pos.y-=1; break;
    case 'left': pos.x-=1; break;
    case 'right': pos.x+=1; break;
    case 'front': pos.z+=1; break;
    case 'back': pos.z-=1; break;
  }
  if(!blocks.some(b=>b.position.equals(pos))) modifyBlock(pos.x,pos.y,pos.z,'add');
}

// ==============================
// MOUSE CLICK (desktop)
// ==============================
document.addEventListener('mousedown', e=>{
  if(!isLocked) return;
  if(e.button===0) raycastBreak();
  else if(e.button===2) raycastPlace();
});
document.addEventListener('contextmenu', e=>e.preventDefault());

// ==============================
// RESIZE
// ==============================
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
